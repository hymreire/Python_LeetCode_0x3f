动态规划可以用递归做，也可以用递推做，有时递推能够起到奇效

打家劫舍问题：
```python
# 198. House Robber

# 方法一：递归搜索 + 保存计算结果 = 记忆化搜索
class Solution:
    def rob(self, nums: List[int]) -> int:
        # 表示从0到i最多能偷多少
        @cache # 缓存就是用来存递归出现过的值
        def dfs(i):
            if i<0:
                return 0
            return max(dfs(i-1),dfs(i-2)+nums[i]) # 要么抢下家，要么抢这家和下下家
        return dfs(len(nums)-1) # 倒着计数好写判断条件

## @cache也可以自己实现
class Solution:
    def rob(self, nums: List[int]) -> int:
        cache=[-1]*len(nums)
        def dfs(i):
            if i<0:
                return 0
            # 自己实现的缓存器，中间加了一个判断条件拦截计算
            if cache[i]!=-1:
                return cache[i]
            res=max(dfs(i-1),dfs(i-2)+nums[i])
            cache[i]=res
            return res
        return dfs(len(nums)-1)

# 方法二：递推
class Solution:
    def rob(self, nums: List[int]) -> int:
        f=[0]*(len(nums)+2) # f[i+2]表示从0到i最多能偷多少 # 将f[0]、f[1]初始化为0可以不用写边界条件
        for i,x in enumerate(nums):
            f[i+2]=max(f[i+1],f[i]+x)
        return f[-1]
    
# 如果不初始化为0，边界条件处理起来极其麻烦：
class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums)==1:
            return nums[0]
        elif len(nums)==2:
            return max(nums[0],nums[1])
        f=[0]*len(nums) # f[i]就是要表示0到i最多偷多少钱
        f[0]=nums[0]
        f[1]=max(nums[0],nums[1])
        for i,x in enumerate(nums[2:]):
            f[i+2]=max(f[i+1],f[i]+x)
        return f[len(nums)-1]

# 方法三：极简递推方程
class Solution:
    def rob(self, nums: List[int]) -> int:
        f0=f1=0
        for x in nums:
            f1,f0=max(f0+x,f1),f1 # 这里利用了python的赋值特性，无需再维护一个缓存变量
        return f1
# 上面这种想不到也无所谓，多做题目就能够自主判断应该选择哪个模型
```