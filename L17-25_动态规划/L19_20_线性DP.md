# L19 20 线性DP

## 最长公共子序列
最长公共子序列，其实和前面的方法差不多：
```python
# 1143. Longest Common Subsequence

# 方法1：记忆化搜索
# 我觉得就是从后往前搜，匹配上就加1，匹配不上就继续往前
# 递归正好将所有的情况都匹配到了
class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        m,n=len(text1),len(text2)
        @cache
        def dfs(i,j):
            # 边界条件
            if i<0 or j<0:
                return 0
            if text1[i]==text2[j]:
                return dfs(i-1,j-1)+1
            return max(dfs(i-1,j),dfs(i,j-1))
        return dfs(m-1,n-1)

# 方法2：递推方程
class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        m,n=len(text1),len(text2)
        f=[[0]*(n+1) for _ in range(m+1)]
        for i,x in enumerate(text1):
            for j,y in enumerate(text2):
                f[i+1][j+1]=f[i][j]+1 if x==y else max(f[i+1][j],f[i][j+1])
        return f[m][n]

# 方法3：滚动数组
class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        m,n=len(text1),len(text2)
        f=[[0]*(n+1) for _ in range(2)]
        for i,x in enumerate(text1):
            for j,y in enumerate(text2):
                f[(i+1)%2][j+1]=f[i%2][j]+1 if x==y else max(f[i%2][j+1],f[(i+1)%2][j])
        return f[m%2][n]

# 方法4：一维数组
class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        f=[0]*(len(text2)+1)
        for x in text1: # 在这个索引下所有一维变量视为i
            pre=0 # f[i][0]
            for j,y in enumerate(text2):
                tem=f[j+1] # f[i][j+1]
                # 分类讨论
                # f[i+1][j+1]=
                # f[i][j]+1
                # max(f[i][j+1],f[i+1][j])
                f[j+1]=pre+1 if x==y else max(f[j],f[j+1])
                pre=tem # f[i][j+1]
        return f[-1]
```

编辑数组，据说曾经是Hard难度，但是背下来不难：
```python
# 72. Edit Distance

# 方法1：记忆化搜索
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        m,n=len(word1),len(word2)
        @cache
        def dfs(i,j): # 将i:转换为j:的最小操作数 # 指针指向字符
            if i<0: # word1前缀空，需补0:j+1前缀
                return j+1
            if j<0: # word2前缀空，需删0:i+1前缀
                return i+1
            if word1[i]==word2[j]: # 匹配，不用操作，指针往前
                return dfs(i-1,j-1)
            # 不匹配，要么删除，要么插入，要么补上
            return min(dfs(i-1,j),dfs(i,j-1),dfs(i-1,j-1))+1
        return dfs(m-1,n-1)

# 方法2：递推方程
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        m,n=len(word1),len(word2)
        f=[[0]*(n+1) for _ in range(m+1)] # f[i][j]是:i到:j的最小操作数
        f[0]=list(range(n+1)) # w1空则插入w2的全部字符
        for i,x in enumerate(word1):
            f[i+1][0]=i+1 # w2空则删除w1全部字符 ## 初始化一定是要给后面使用的
            for j,y in enumerate(word2):
                f[i+1][j+1]=f[i][j] if x==y else min(f[i][j+1],f[i+1][j],f[i][j])+1
        return f[m][n]

# 方法3：滚动数组
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        m,n=len(word1),len(word2)
        f=[list(range(n+1)),[0]*(n+1)] # list()，圆括号不是方括号 # m,n的含义弄懂而不是硬背
        for i,x in enumerate(word1):
            f[(i+1)%2][0]=i+1
            for j,y in enumerate(word2):
                f[(i+1)%2][j+1]=f[i%2][j] if x==y else min(f[i%2][j+1],f[(i+1)%2][j],f[i%2][j])+1
        return f[m%2][n]

# 方法4：一维数组
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        n=len(word2)
        f=list(range(n+1)) # 初始化f[0][j]
        for i,x in enumerate(word1):
            pre=f[0]
            f[0]+=1
            for j,y in enumerate(word2):
                tmp=f[j+1]
                f[j+1]=pre if x==y else min(pre,f[j],f[j+1])+1
                pre=tmp # 更新
        return f[-1]
```