前两道很简单，第三道有难度。

二叉树直径：
```python
# 543. Diameter of Binary Tree

class Solution:
    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:
        ans=0
        def dfs(node):
            if node==None:
                return -1 # 因为后面+1
            ll=dfs(node.left)+1
            lr=dfs(node.right)+1
            nonlocal ans
            ans=max(ans,ll+lr)
            return max(ll,lr)
        dfs(root)
        return ans
```

考虑节点值：
```python
# 124. Binary Tree Maximum Path Sum

class Solution:
    def maxPathSum(self, root: Optional[TreeNode]) -> int:
        ans=-inf
        def dfs(node):
            if node==None:
                return 0
            l=dfs(node.left)
            r=dfs(node.right)
            nonlocal ans
            ans=max(ans,l+r+node.val)
            return max(max(l,r)+node.val,0) # 左链和右链最大值，小于0直接不选（空集）
        dfs(root)
        return ans
```

考虑字符：
```python
# 2246. Longest Path With Different Adjacent Characters

class Solution:
    def longestPath(self, parent: List[int], s: str) -> int:
        n=len(parent)
        g=[[] for _ in range(n)]
        for i in range(1,n):
            g[parent[i]].append(i)
        ans=0
        def dfs(x): # x的单根最长路径
            nonlocal ans
            max_len=0 # 第一支先算单根长度
            for y in g[x]:
                len_=dfs(y)+1 # y分支的长度（不考虑满足条件）
                if s[x]!=s[y]:
                    ans=max(ans,max_len+len_) # 满足条件考虑两个分支最大值
                    max_len=max(max_len,len_) # 更新单根最大路径
            return max_len
        dfs(0)
        return ans+1 # 最后算上根节点（前面只算了边长）
```