# 回溯
回溯：增量构造答案，递归实现

边界条件和非边界条件

回溯三问：当前操作——>子问题——>下一个子问题

当前操作：枚举索引 i 要填入的字母

子问题：构造 >=i 的部分

下一个子问题：构造 >=i+1 的部分

本质上就是dfs，深度优先搜索

电话问题：
```python
# 按键映射
MAPPING="","","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"

class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        n=len(digits)

        # 分类讨论
        if n==0:
            return []
        
        ans=[]
        path=[""]*n # 列表乘法，缓存字符列表

        # 回溯本质是递归（dfs，深度优先搜索），一般与循环和枚举相配合
        def dfs(i):
            # 边界条件
            if i==n:
                ans.append("".join(path)) # 列表转字符串，其中""是连接符
                return
            
            for c in MAPPING[int(digits[i])]: # 元组索引也是用方括号
                path[i]=c
                dfs(i+1) # 递降

        dfs(0)

        return ans
```

## 子集型回溯
子集型回溯，集合的选或不选问题

子集问题，用pop撤销当前分支很重要，始终记住有选必有撤：
```python
# 方法一：选或不选
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        n=len(nums)
        ans=[]
        path=[]

        def dfs(i):
            # 边界条件
            if i==n:
                ans.append(path.copy()) # path全局变化，需存副本
                return
            
            # 递降的两种选择：选或不选，两种情况一定都会出现
            # 不选
            dfs(i+1)
            # 选，有选就有撤
            path.append(nums[i])
            dfs(i+1)
            path.pop() # 恢复现场（撤销当前分支，恢复到上一个状态）

        dfs(0)

        return ans

# 方法二：枚举选择：从空集开始，按树状图形式添入
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        n=len(nums)
        ans=[]
        path=[]

        def dfs(i):
            ans.append(path.copy())
            for j in range(i,n):
                # 选择
                path.append(nums[j])
                # 递降
                dfs(j+1)
                path.pop() # 有选必有撤

        dfs(0)

        return ans
```

回文子串问题：
```python
# 方法一：选或不选：对于每个i，决定是否在它后面进行切分
class Solution:
    def partition(self, s: str) -> List[List[str]]:
        n=len(s)
        ans=[]
        path=[]

        # start——>i 切分后是否为回文串
        def dfs(i,start):
            if i==n: # 边界条件
                ans.append(path.copy())
                return # 终止符
            # 不选
            if i<n-1:
                dfs(i+1,start)
            # 选
            t=s[start:i+1]
            if t==t[::-1]: # 是回文串
                path.append(t) # 加入当前切割组合
                dfs(i+1,i+1) # 递降
                path.pop() # 有选必有撤
        
        dfs(0,0)

        return ans

# 方法二：枚举选择
class Solution:
    def partition(self, s: str) -> List[List[str]]:
        n=len(s)
        ans=[]
        path=[]
        def dfs(i):
            # 边界条件
            if i==n:
                ans.append(path.copy())
                return # 终止符
            for j in range(i,n): # 切片范围，小心数组越界
                # 选择
                t=s[i:j+1]
                if t==t[::-1]: # 判断回文
                    path.append(t)
                    dfs(j+1) # 递降
                    path.pop() # 有选必有撤
        dfs(0)
        return ans
```

## 组合型回溯
组合问题，本质上还是用先前提到的那两个模板。唯一区别是，从高到低，在计数上比较方便，方便剪枝优化的计算，但是实际上，如果你要正着写，肯定也有正着写的方法，只是剪枝优化的上下界需要更小心的判断：
```python
# 方案一：枚举选择
class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:
        ans=[]
        path=[]
        # 从i开始往下选取剩余的数
        def dfs(i):
            d=k-len(path) # 剩余这么多数
            # 边界条件，不剩余就结束
            if d==0:
                ans.append(path.copy())
                return
            for j in range(i,d-1,-1): # 从[1,d-1]，至少留够d-1个数给后面选择
                path.append(j)
                dfs(j-1) # 递降
                path.pop() # 有选必有撤
        dfs(n)
        return ans

# 方案二：选或不选
class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:
        ans=[]
        path=[]
        def dfs(i):
            d=k-len(path)
            if d==0:
                ans.append(path.copy())
                return
            # 余量充足，可以不选
            if i>d:
                dfs(i-1)
            # 选
            path.append(i)
            dfs(i-1)
            path.pop() # 有选必有撤
        dfs(n)
        return ans
```

组合总和，和组合的做法很像，但是需要额外维护一个变量表示剩余总和：
```python
# 方法一：枚举选择
class Solution:
    # k是一个全局变量不要管
    def combinationSum3(self, k: int, n: int) -> List[List[int]]:
        ans=[]
        path=[]
        # 输入当前最大值i和剩余总和ls，输出剩余组合
        def dfs(i,ls):
            d=k-len(path)
            # 这里很巧妙，d=0时，l被夹逼为0
            if ls<0 or ls>(2*i-d+1)*d/2:
                return
            if d==0: # 加入列表一定要copy
                ans.append(path.copy())
                return
            for j in range(i,d-1,-1): # 范围遵循左闭右开
                path.append(j)
                dfs(j-1,ls-j) # ls才是动态变化量
                path.pop() # 弹出的方法一定要加括号
        dfs(9,n)
        return ans

# 方法二：选或不选
class Solution:
    def combinationSum3(self, k: int, n: int) -> List[List[int]]:
        ans=[]
        path=[]
        def dfs(i,ls):
            d=k-len(path)
            # 这里很巧妙，d=0时，l被夹逼为0
            if ls<0 or ls>(2*i-d+1)*d/2: # 写判断条件时要细心不能写错符号
                return
            if d==0:
                ans.append(path.copy())
                return
            # 不选
            if i>d:
                dfs(i-1,ls)
            # 选
            path.append(i)
            dfs(i-1,ls-i)
            path.pop()
        dfs(9,n)
        return ans
```

