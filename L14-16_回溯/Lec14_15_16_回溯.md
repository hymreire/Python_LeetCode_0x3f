# 回溯
回溯：增量构造答案，递归实现

边界条件和非边界条件

回溯三问：当前操作——>子问题——>下一个子问题

当前操作：枚举索引 i 要填入的字母

子问题：构造 >=i 的部分

下一个子问题：构造 >=i+1 的部分

本质上就是dfs，深度优先搜索

电话问题：
```python
# 按键映射
MAPPING="","","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"

class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        n=len(digits)

        # 分类讨论
        if n==0:
            return []
        
        ans=[]
        path=[""]*n # 列表乘法，缓存字符列表

        # 回溯本质是递归（dfs，深度优先搜索），一般与循环和枚举相配合
        def dfs(i):
            # 边界条件
            if i==n:
                ans.append("".join(path)) # 列表转字符串，其中""是连接符
                return
            
            for c in MAPPING[int(digits[i])]: # 元组索引也是用方括号
                path[i]=c
                dfs(i+1) # 递降

        dfs(0)

        return ans
```

## 子集型回溯
子集型回溯，集合的选或不选问题

子集问题，用pop撤销当前分支很重要，始终记住有选必有撤：
```python
# 方法一：选或不选
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        n=len(nums)
        ans=[]
        path=[]

        def dfs(i):
            # 边界条件
            if i==n:
                ans.append(path.copy()) # path全局变化，需存副本
                return
            
            # 递降的两种选择：选或不选，两种情况一定都会出现
            # 不选
            dfs(i+1)
            # 选，有选就有撤
            path.append(nums[i])
            dfs(i+1)
            path.pop() # 恢复现场（撤销当前分支，恢复到上一个状态）

        dfs(0)

        return ans

# 方法二：枚举选择：从空集开始，按树状图形式添入
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        n=len(nums)
        ans=[]
        path=[]

        def dfs(i):
            ans.append(path.copy())
            for j in range(i,n):
                # 选择
                path.append(nums[j])
                # 递降
                dfs(j+1)
                path.pop() # 有选必有撤

        dfs(0)

        return ans
```

回文子串问题：
```python
# 方法一：选或不选：对于每个i，决定是否在它后面进行切分
class Solution:
    def partition(self, s: str) -> List[List[str]]:
        n=len(s)
        ans=[]
        path=[]

        # start——>i 切分后是否为回文串
        def dfs(i,start):
            if i==n: # 边界条件
                ans.append(path.copy())
                return # 终止符
            # 不选
            if i<n-1:
                dfs(i+1,start)
            # 选
            t=s[start:i+1]
            if t==t[::-1]: # 是回文串
                path.append(t) # 加入当前切割组合
                dfs(i+1,i+1) # 递降
                path.pop() # 有选必有撤
        
        dfs(0,0)

        return ans

# 方法二：枚举选择
class Solution:
    def partition(self, s: str) -> List[List[str]]:
        n=len(s)
        ans=[]
        path=[]
        def dfs(i):
            # 边界条件
            if i==n:
                ans.append(path.copy())
                return # 终止符
            for j in range(i,n): # 切片范围，小心数组越界
                # 选择
                t=s[i:j+1]
                if t==t[::-1]: # 判断回文
                    path.append(t)
                    dfs(j+1) # 递降
                    path.pop() # 有选必有撤
        dfs(0)
        return ans
```

## 组合型回溯
组合问题，本质上还是用先前提到的那两个模板。唯一区别是，从高到低，在计数上比较方便，方便剪枝优化的计算，但是实际上，如果你要正着写，肯定也有正着写的方法，只是剪枝优化的上下界需要更小心的判断：
```python
# 方案一：枚举选择
class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:
        ans=[]
        path=[]
        # 从i开始往下选取剩余的数
        def dfs(i):
            d=k-len(path) # 剩余这么多数
            # 边界条件，不剩余就结束
            if d==0:
                ans.append(path.copy())
                return
            for j in range(i,d-1,-1): # 从[1,d-1]，至少留够d-1个数给后面选择
                path.append(j)
                dfs(j-1) # 递降
                path.pop() # 有选必有撤
        dfs(n)
        return ans

# 方案二：选或不选
class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:
        ans=[]
        path=[]
        def dfs(i):
            d=k-len(path)
            if d==0:
                ans.append(path.copy())
                return
            # 余量充足，可以不选
            if i>d:
                dfs(i-1)
            # 选
            path.append(i)
            dfs(i-1)
            path.pop() # 有选必有撤
        dfs(n)
        return ans
```

组合总和，和组合的做法很像，但是需要额外维护一个变量表示剩余总和：
```python
# 方法一：枚举选择
class Solution:
    # k是一个全局变量不要管
    def combinationSum3(self, k: int, n: int) -> List[List[int]]:
        ans=[]
        path=[]
        # 输入当前最大值i和剩余总和ls，输出剩余组合
        def dfs(i,ls):
            d=k-len(path)
            # 这里很巧妙，d=0时，l被夹逼为0
            if ls<0 or ls>(2*i-d+1)*d/2:
                return
            if d==0: # 加入列表一定要copy
                ans.append(path.copy())
                return
            for j in range(i,d-1,-1): # 范围遵循左闭右开
                path.append(j)
                dfs(j-1,ls-j) # ls才是动态变化量
                path.pop() # 弹出的方法一定要加括号
        dfs(9,n)
        return ans

# 方法二：选或不选
class Solution:
    def combinationSum3(self, k: int, n: int) -> List[List[int]]:
        ans=[]
        path=[]
        def dfs(i,ls):
            d=k-len(path)
            # 这里很巧妙，d=0时，l被夹逼为0
            if ls<0 or ls>(2*i-d+1)*d/2: # 写判断条件时要细心不能写错符号
                return
            if d==0:
                ans.append(path.copy())
                return
            # 不选
            if i>d:
                dfs(i-1,ls)
            # 选
            path.append(i)
            dfs(i-1,ls-i)
            path.pop()
        dfs(9,n)
        return ans
```

括号生成问题：
```python
# 方法一：选或不选
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        m=2*n # 括号总数
        ans=[]
        path=[""]*m # 存储当前组合
        # 输入左右括号个数，输出剩余位置合法的path
        def dfs(l,r):
            # 边界条件：右括号数量为n（前提是约束左右括号不越界）
            if r==n:
                ans.append("".join(path))
                return
            if l<n: # 约束条件，左括号不得大于n
                path[l+r]="("
                dfs(l+1,r)
            if r<l: # 约束条件，右括号不得大于左括号
                path[l+r]=")" # 思考一下：覆盖等价于不选左括号吗？
                dfs(l,r+1)
        dfs(0,0)
        return ans

# 方法二：枚举选择
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        ans=[]
        path=[] # 记录左括号下标，因此本题不涉及右括号直接操作
        # 输入：当前括号总数，输出左右括号差值
        def dfs(i,d):
            # 边界条件：左括号位置完全确定
            if len(path)==n:
                s=[")"]*(2*n)
                for j in path:
                    s[j]="("
                ans.append("".join(s))
                return # 一定要return终止，否则递降不会结束
            # 枚举选择：差值就是可选右括号数量，遍历
            # 本题不涉及右括号直接操作，确定左括号索引即可实现等价效果
            # 一次只处理一个左括号索引不会乱
            for r in range(d+1):
                path.append(i+r)
                dfs(i+r+1,d-r+1)
                path.pop()
        dfs(0,0)
        return ans
```

## 排列型回溯
排列型回溯

全排列，一个判断标记能减轻大量计算：
```python
# 46. Permutations

# 枚举选择的方法
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        n=len(nums)
        ans=[]
        path=[0]*n # 初始化一个可覆盖的缓存
        on_path=[False]*n # 初始化一个可覆盖的判断标记
        # 输入当前的位置，填入合法的数值
        def dfs(i):
            if i==n: # 边界条件一般就是遍历结束的指针位置
                ans.append(path.copy()) # 方法一定要加括号
                return # 终止符不能忘记
            for j,on in enumerate(on_path):
                if not on:
                    path[i]=nums[j] # 赋值是什么要看清
                    on_path[j]=True
                    dfs(i+1)
                    on_path[j]=False
        dfs(0)
        return ans
```

N皇后问题，英文题目居然缺少信息，逆天，看来必要的时候还是得结合中文题目看
```python
# 枚举选择
class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        ans=[]
        path=[0]*n # 缓存变量：记录所占列，覆盖制
        col=[False]*n # 记录该列是否被占用
        diag_lu=[False]*(2*n-1) # 记录行列和是否被占用，从0到2n-2共2n-1个
        diag_ru=[False]*(2*n-1) # 记录行列差是否被占用，从-n+1到n-1共2n-1个
        # 输入行号r，调整改行对应的列号c
        def dfs(r):
            if r==n:
                ans.append(["."*c+"Q"+"."*(n-c-1) for c in path])
                return
            for c,cf in enumerate(col):
                if not cf and not diag_lu[r+c] and not diag_ru[r-c]:
                    path[r]=c
                    col[c]=diag_lu[r+c]=diag_ru[r-c]=True
                    dfs(r+1)
                    col[c]=diag_lu[r+c]=diag_ru[r-c]=False
        dfs(0)
        return ans
```

N皇后2，唯一区别是求数量，其实就没区别：
```python
# 52. N-Queens II

class Solution:
    def totalNQueens(self, n: int) -> int:
        ans=0
        # col=[0]*n # 这行忽略
        col_mark=[False]*n
        diag_lu=[False]*(2*n-1)
        diag_ru=[False]*(2*n-1)
        def dfs(r):
            nonlocal ans # 必须声明非局部
            if r==n:
                ans+=1
                return
            for c,cm in enumerate(col_mark):
                if not cm and not diag_lu[r+c] and not diag_ru[r-c]:
                    # col[r]=c # 这行忽略
                    col_mark[c]=diag_lu[r+c]=diag_ru[r-c]=True
                    dfs(r+1)
                    col_mark[c]=diag_lu[r+c]=diag_ru[r-c]=False
        dfs(0)
        return ans
```

至此，回溯例题全部刷完，习题有时间再说吧