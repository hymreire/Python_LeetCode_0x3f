我来详细分析这道经典的回溯算法题 —— **电话号码的字母组合**（LeetCode 17）。

## 📋 题目理解

给定一个包含数字 2-9 的字符串，返回所有可能的字母组合。数字到字母的映射就像电话按键：
- 2 → "abc"
- 3 → "def"
- 4 → "ghi"
- 5 → "jkl"
- 6 → "mno"
- 7 → "pqrs"
- 8 → "tuv"
- 9 → "wxyz"

## 🎯 核心思想：回溯算法

这是一个典型的**排列组合问题**，使用回溯算法来枚举所有可能的组合。

### 回溯算法的关键要素

1. **选择** - 当前位置可以选择哪些字母
2. **路径** - 已经做出的选择
3. **结束条件** - 何时停止递归

## 🔍 算法详解

### 1. 数据结构设计

```python
MAPPING = "", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"
```
- 索引 0 和 1 为空字符串（数字 0 和 1 不对应字母）
- 索引 2-9 对应电话按键的字母映射

### 2. 递归函数 `dfs(i)` 的含义

**核心理解**：`dfs(i)` 表示**从下标 i 开始，枚举剩余所有位置的字母组合**

```python
def dfs(i: int) -> None:
```

- **参数 i**：当前正在处理 `digits[i]` 这个数字
- **递归含义**：枚举 `digits[i]` 对应的所有字母，然后递归处理 `digits[i+1]`

### 3. 递归边界

```python
if i == n:
    ans.append(''.join(path))
    return
```

- 当 `i == n` 时，说明已经处理完所有数字
- 此时 `path` 中存储了一个完整的字母组合
- 将其加入答案列表

### 4. 递归过程（回溯的核心）

```python
for c in MAPPING[int(digits[i])]:  # 枚举当前数字对应的所有字母
    path[i] = c                     # 选择：做选择
    dfs(i + 1)                       # 递归：处理下一个位置
    # 不需要显式回溯，因为下次循环会直接覆盖 path[i]
```

**关键点**：
- 遍历当前数字对应的每个字母
- 将字母放入 `path[i]`
- 递归处理下一个位置 `i+1`
- 不需要显式的 `path[i] = ''` 来恢复现场，因为下次循环会直接覆盖

### 5. 为什么 `path` 长度初始化为 `n`？

```python
path = [''] * n  # 预分配空间
```

**优势**：
- 避免频繁的列表 append 和 pop 操作
- 直接通过索引 `path[i]` 覆盖，效率更高
- 不需要显式回溯（恢复现场）

## 🌲 递归树示例

假设输入 `digits = "23"`：

```
                    root
                     |
        ┌────────────┼────────────┐
        a            b             c
        |            |             |
    ┌───┼───┐    ┌───┼───┐    ┌───┼───┐
    d   e   f    d   e   f    d   e   f
    |   |   |    |   |   |    |   |   |
   "ad""ae""af" "bd""be""bf" "cd""ce""cf"
```

- 第一层：枚举 `digits[0] = '2'` → `"abc"`
- 第二层：枚举 `digits[1] = '3'` → `"def"`
- 叶子节点：得到 9 个组合

## 📊 执行流程追踪

以 `digits = "23"` 为例：

```python
dfs(0):
  c = 'a' → path = ['a', '']
    dfs(1):
      c = 'd' → path = ['a', 'd'] → i=2，加入 "ad"
      c = 'e' → path = ['a', 'e'] → i=2，加入 "ae"
      c = 'f' → path = ['a', 'f'] → i=2，加入 "af"
  
  c = 'b' → path = ['b', '']
    dfs(1):
      c = 'd' → path = ['b', 'd'] → i=2，加入 "bd"
      c = 'e' → path = ['b', 'e'] → i=2，加入 "be"
      c = 'f' → path = ['b', 'f'] → i=2，加入 "bf"
  
  c = 'c' → path = ['c', '']
    dfs(1):
      c = 'd' → path = ['c', 'd'] → i=2，加入 "cd"
      c = 'e' → path = ['c', 'e'] → i=2，加入 "ce"
      c = 'f' → path = ['c', 'f'] → i=2，加入 "cf"
```

## 💡 回溯算法模板

这道题体现了回溯算法的标准模板：

```python
def backtrack(path, choices):
    if 满足结束条件:
        result.add(path)
        return
    
    for choice in choices:
        做选择：path.add(choice)
        backtrack(path, 剩余选择)
        撤销选择：path.remove(choice)  # 本题通过覆盖实现
```

## ⚡ 复杂度分析

**时间复杂度**：O(n × 4<sup>n</sup>)
- 最坏情况（如 "7777"），每个数字对应 4 个字母
- 递归树是一个满四叉树，节点数为 4<sup>n</sup>
- 每个叶子节点需要 O(n) 时间复制 path

**空间复杂度**：O(n)
- 递归调用栈深度为 n
- path 数组长度为 n
- 不计入返回值

## 🎓 关键要点总结

1. **`dfs(i)` 的含义**：处理从 i 到末尾的所有组合（不只是 i）
2. **预分配 path**：避免频繁增删，直接覆盖更高效
3. **隐式回溯**：通过下次循环覆盖实现，无需显式撤销
4. **递归树结构**：多叉树遍历，每层对应一个数字位置

这是一道非常经典的回溯入门题，掌握它的思路后可以解决很多类似的排列组合问题！🎯